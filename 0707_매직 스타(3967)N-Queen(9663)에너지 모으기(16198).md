## 3967_매직스타

1. 더하여 26이 나와야 하는 줄은 총 6줄 => 미리 star 배열에 만듦.
2. 배열 arr에 입력을 받는다.
 - x가 나오면 따로 list에 저장 => 내가 앞으로 채워야 하는 대상
 - x와 .이 아닌 다른 값은 알파벳이므로 (그리고 알파벳은 A~L까지 한 번씩만 나올 수 있으므로) 따로 alphabet 배열에서 관리
	 
3. setMagicStar()에서 arr을 다 채운다. cnt가 list.size()만큼 되면 다 채웠다는 뜻으로, 합이 26인지 isAvailable()에서 확인

```
import java.io.*;
import java.util.*;

public class Main_백준_3967_매직스타 {

	private static StringBuilder sb;
	private static char[][] arr;
	private static ArrayList<int[]> list;
	private static boolean[] alphabet;
	private static boolean flag;
	private static int[][][] star = { { { 0, 4 }, { 1, 3 }, { 2, 2 }, { 3, 1 } }, { { 0, 4 }, { 1, 5 }, { 2, 6 }, { 3, 7 } },
			{ { 1, 1 }, { 1, 3 }, { 1, 5 }, { 1, 7 } }, { { 1, 1 }, { 2, 2 }, { 3, 3 }, { 4, 4 } },
			{ { 1, 7 }, { 2, 6 }, { 3, 5 }, { 4, 4 } }, { { 3, 1 }, { 3, 3 }, { 3, 5 }, { 3, 7 } } };

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		sb = new StringBuilder();
		arr = new char[5][9];
		list = new ArrayList<int[]>();
		alphabet = new boolean[13];
		for (int i = 0; i < 5; i++) {
			String s = br.readLine();
			for (int j = 0; j < 9; j++) {
				arr[i][j] = s.charAt(j);
				if (arr[i][j] == 'x') { // 채워야 할 대상
					list.add(new int[] { i, j });
				} else if (arr[i][j] != '.') {
					alphabet[(int) arr[i][j] - 64] = true;
				}
			}
		}

		setMagicStar(0);
		System.out.println(sb);
	}

	private static void setMagicStar(int cnt) {
		if(flag) return;
		if(cnt == list.size() && isAvailable()) {
			flag = true;
			for(int i=0; i<5; i++) {
				for(int j=0; j<9; j++) {
					sb.append(arr[i][j]);
				}
				sb.append("\n");
			}
			return;
		}
		for(int i=1; i<=12; i++) {
			if(!alphabet[i]) {
				int[] p = list.get(cnt);
				arr[p[0]][p[1]] = (char)(i+64);
				alphabet[i] = true;
				setMagicStar(cnt+1);
				alphabet[i] = false;
			}
		}
	}

	private static boolean isAvailable() {
		for(int i=0; i<6; i++) {
			int sum = 0;
			for(int j=0; j<4; j++) {
				sum += (int)(arr[star[i][j][0]][star[i][j][1]] - 64);
			}
			if(sum != 26) return false;
		}
		return true;
	}
}
```


## 9663_NQUEEN

1. 어차피 한 줄에 다 같이 놓을 수 없으므로 1차원 배열 col을 이용해 열 번호만 저장
2. 다음 줄에 순서대로 isAvailable()을 확인하며 1번 칸부터 N번 칸까지 놓아본다.
3. 만약 열 번호가 끝까지 갔다면, 경우의 수 하나 증가

```
import java.io.*;
import java.util.*;

public class Main_백준_9663_NQueen {
	
	private static int N, ans;
	private static int[] col;

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		N = Integer.parseInt(br.readLine());
		col = new int[N+1]; // 어차피 한 줄에 다같이 놓을 수 없다. => 열 번호만 저장!
		setQueen(0);
		System.out.println(ans);
	}

	private static void setQueen(int row) {
		if(!isAvailable(row)) { // 그 자리에 놓아질 수 없다.
			return;
		}
		if(row == N) { // 다 놓아짐
			ans++;
			return;
		}
		// 자식노드를 만들어 검사
		for(int i=1; i<=N; i++) {
			col[row+1] = i;
			setQueen(row+1);
		}
		
	}

	private static boolean isAvailable(int row) {
		// 열의 번호가 같거나 대각선에 위치한 경우 false
		for(int i=1; i<row; i++) {
			if(col[i] == col[row] || Math.abs(col[i]-col[row]) == row-i) {
				return false;
			}
		}
		return true;
	}
}
```


## 16198_에너지모으기

1. 편하게 지우고 싶어 list를 이용하여 입력을 받음

```
import java.io.*;
import java.util.*;

public class Main_백준_16198_에너지모으기 {

	private static int N;
	private static ArrayList<Integer> list;
	public static int max;

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		N = Integer.parseInt(br.readLine()); // 에너지 구슬의 개수
		list = new ArrayList<Integer>();
		StringTokenizer st = new StringTokenizer(br.readLine(), " ");
		for (int i = 0; i < N; i++) {
			list.add(Integer.parseInt(st.nextToken()));
		}
		gatherEnergy(0);
		System.out.println(max);
	}

	private static void gatherEnergy(int weight) {
		if (list.size() <= 2) { // list.size() <= 2 라는 건 더 이상 가운데에 제거할 구슬이 없음
			if (max < weight) {
				max = weight;
			}
			return;
		}
		for (int i = 1; i < list.size() - 1; i++) { // 맨 앞, 맨 뒤는 고를 수 없으니 
			int sum = 0;
			sum += list.get(i - 1) * list.get(i + 1); // 제거하고자 하는 것 왼쪽 오른쪽 에너지를 구하고
			int num = list.get(i); // list에 복귀시켜줄 i번째 num 저장
			list.remove(i);
			gatherEnergy(weight + sum);
			list.add(i, num); // list 복귀
		}

	}

}

```